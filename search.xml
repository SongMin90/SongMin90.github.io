<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[可批量转换编码]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%8F%AF%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/SongMin90/CodedConversion windows配置java环境点击“文件编码转换工具.jar”运行即可。下载工具]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>编码转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读取文件夹的全部文件]]></title>
    <url>%2F2017%2F10%2F30%2F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在java开发中，很多情况需要我们对一个文件夹里的文件进行各种操作，于是这里我们可以使用递归的方式循环读取文件夹文件1234567891011public void find(String src) &#123; File file = new File(src); File[] list = file.listFiles(); for (File f : list) &#123; if(f.isDirectory()) &#123; find(f); &#125; else &#123; // 这里即对文件进行操作 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安卓倒计时定时器]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%AE%89%E5%8D%93%E5%80%92%E8%AE%A1%E6%97%B6%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在安卓开发引导界面的时候，我们可以使用安卓自带的定时器CountDownTimer12345678910111213new CountDownTimer(3000, 1000) &#123; // 第一个时间为总时间，第二个为间隔时间 @Override public void onTick(long l) &#123; // 每次循环将执行 tv_time.setText(l/1000 + " s"); &#125; @Override public void onFinish() &#123; // 计时结束后执行 Intent intent = new Intent(GuideActivity.this, MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125;&#125;.start(); 相比Handler，这种方式将使代码变得十分简洁和方便。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkGo缓存的使用]]></title>
    <url>%2F2017%2F10%2F30%2FOkGo%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[OkGo, 一个基于okhttp的标准RESTful风格的网络框架github地址：https://github.com/jeasonlzy/okhttp-OkGo 首先添加库1compile 'com.lzy.net:okgo:3.0.4' 另外得到的json转bean将用到Gson，所以还需添加库12compile 'com.google.code.gson:gson-parent:2.8.1'compile 'com.google.code.gson:gson:2.8.1' 缓存示例请求1234567891011121314151617String url = "http://118.89.101.23:8080/order/getCommittedOrdersorderState=1&amp;stuId=2015040201143";OkGo.&lt;Orders&gt;get(url) .tag(this) .cacheKey(url) .cacheMode(CacheMode.FIRST_CACHE_THEN_REQUEST) .cacheTime(3600 * 24 * 30) .execute(new OrdersCallback()&#123; @Override public void onSuccess(Response&lt;Orders&gt; response) &#123; jiexi(response); &#125; @Override public void onCacheSuccess(Response&lt;Orders&gt; response) &#123; jiexi(response); &#125; &#125;); 定义的Callback需要继承AbsCallback12345678910111213public class OrdersCallback extends AbsCallback&lt;Orders&gt; &#123; @Override public void onSuccess(Response&lt;Orders&gt; response) &#123; &#125; @Override public Orders convertResponse(okhttp3.Response response) throws Throwable &#123; ResponseBody body = response.body(); return new Gson().fromJson(body.charStream(), Orders.class); &#125; &#125; 注意事项使用缓存前，必须让涉及到缓存javaBean对象实现Serializable接口，否者会报NotSerializableException。因为缓存的原理是将对象序列化后直接写入数据库中，如果不实现Serializable接口，会导致对象无法序列化，进而无法写入到数据库中，也就达不到缓存的效果。 缓存相关的API cacheKey每次框架是根据这个cacheKey去到数据库中寻找缓存的，所以一般来说，每个不同功能的请求都要设置不一样的cacheKey，如果相同，会导致数据库中的缓存数据发生覆盖或错乱。如果不指定cacheKey，默认是用url带参数的全路径名为cacheKey。 cacheMode目前默认提供了五种CacheMode缓存模式，不同的模式会有不同的Callback回调顺序，详细见下方的回调顺序NO_CACHE：不使用缓存，该模式下cacheKey、cacheTime 参数均无效DEFAULT：按照HTTP协议的默认缓存规则，例如有304响应头时缓存。REQUEST_FAILED_READ_CACHE：先请求网络，如果请求网络失败，则读取缓存，如果读取缓存失败，本次请求失败。IF_NONE_CACHE_REQUEST：如果缓存不存在才请求网络，否则使用缓存。FIRST_CACHE_THEN_REQUEST：先使用缓存，不管是否存在，仍然请求网络。 cacheTime当前缓存的有效时间是多长，单位毫秒，上面示例是3600秒，也就是一个小时，这个根据自己需要设置，如果不设置，默认是CacheEntity.CACHE_NEVER_EXPIRE=-1，也就是永不过期。该参数对DEFAULT模式是无效的，因为该模式是完全遵循标准的http协议的，缓存时间是依靠服务端响应头来控制，所以客户端的cacheTime参数无效。 cachePolicy这个是自定义的缓存策略，内置的五大缓存模式其实就是这个缓存策略CachePolicy接口的五种不同实现，如果这五种模式不能满足你，你完全可以自行实现这个接口，写出属于你自己的缓存规则。 onCacheSuccess当缓存读取成功后，回调的是这个方法，如果你只复写了onSuccess方法，是无法获取缓存的，这里要注意。 回调顺序1.) 无缓存模式 CacheMode.NO_CACHE网络请求成功 onStart -&gt; convertResponse -&gt; onSuccess -&gt; onFinish网络请求失败 onStart -&gt; onError -&gt; onFinish 2.) 默认缓存模式,遵循304头 CacheMode.DEFAULT网络请求成功,服务端返回非304 onStart -&gt; convertResponse -&gt; onSuccess -&gt; onFinish网络请求成功服务端返回304 onStart -&gt; onCacheSuccess -&gt; onFinish网络请求失败 onStart -&gt; onError -&gt; onFinish 3.) 请求网络失败后读取缓存 CacheMode.REQUEST_FAILED_READ_CACHE网络请求成功,不读取缓存 onStart -&gt; convertResponse -&gt; onSuccess -&gt; onFinish网络请求失败,读取缓存成功 onStart -&gt; onCacheSuccess -&gt; onFinish网络请求失败,读取缓存失败 onStart -&gt; onError -&gt; onFinish 4.) 如果缓存不存在才请求网络，否则使用缓存 CacheMode.IF_NONE_CACHE_REQUEST已经有缓存,不请求网络 onStart -&gt; onCacheSuccess -&gt; onFinish没有缓存请求网络成功 onStart -&gt; convertResponse -&gt; onSuccess -&gt; onFinish没有缓存请求网络失败 onStart -&gt; onError -&gt; onFinish 5.) 先使用缓存，不管是否存在，仍然请求网络 CacheMode.FIRST_CACHE_THEN_REQUEST无缓存时,网络请求成功 onStart -&gt; convertResponse -&gt; onSuccess -&gt; onFinish无缓存时,网络请求失败 onStart -&gt; onError -&gt; onFinish有缓存时,网络请求成功 onStart -&gt; onCacheSuccess -&gt; convertResponse -&gt; onSuccess -&gt; onFinish有缓存时,网络请求失败 onStart -&gt; onCacheSuccess -&gt; onError -&gt; onFinish 完成]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>OkGo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置JavaWeb环境，安装Mysql和Tomcat]]></title>
    <url>%2F2017%2F10%2F30%2FLinux%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%AE%89%E8%A3%85Mysql%E5%92%8CTomcat%2F</url>
    <content type="text"><![CDATA[1、设置Linux字符集为中文1vim /etc/sysconfig/i18n 默认：LANG=”en_US.UTF-8”SYSFONiT=”latarcyrheb-sun16”改为：LANG=”zh_CN.UTF-8”LANGUAGE=”zh_CN.gbk:zh_CN.gbk:zh_CN”SUPPORTED=”zh_CN.gbk:zh_CN:zh:en_US.UTF-8:en_US:en”SYSFONT=”lat0-sun16”1vim /etc/profile export LC_ALL=”zh_CN.UTF-8”export LANG=”zh_CN.UTF-8” 查看编码1locale 先更新yum源1yum -y update 2、安装java环境123yum -y list java* //查看yum库中的java安装包yum -y install java-1.8.0-openjdk* //找到一个直接安装java -version //查看安装的java版本 3、安装mysql123wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 成功安装之后重启mysql服务 如果yum包中有mysql-community-server，则直接以下命令即可1yum -y install mysql* 重启mysql1service mysqld restart 初次安装mysql是root账户是没有密码的，设置密码的方法1234mysql -urootmysql&gt; set password for 'root'@'localhost' = password('mypasswd');mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'sa' WITH GRANT OPTION; //此种设置方法可以让外部软件navicat连接数据库mysql&gt; exit 搞定！ 4、安装tomcat123yum -y list tomcat* //查看yum库中的tomcat安装包yum -y install tomcat* //找到一个直接安装service tomcat start //启动tomcat]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎访问SongM的个人博客！！！]]></title>
    <url>%2F2017%2F10%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[博客采用Hexo建站，欢迎大家访问！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>欢迎访问</tag>
      </tags>
  </entry>
</search>
